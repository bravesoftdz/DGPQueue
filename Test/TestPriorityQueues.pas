unit TestPriorityQueues;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Generics.Defaults, Generics.Collections, System.SysUtils,
  PriorityQueues;

type
  // Test methods for class PriorityQueue<E>

  TestIntegerPriorityQueue = class(TTestCase)
  strict private
    FPriorityQueue: PriorityQueue<integer>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetCount;
    procedure TestEnqueue;
    procedure TestDequeue;
    procedure TestClear;
    procedure TestContains;
    procedure TestRemove;
    procedure TestEnumerator;
    procedure TestDequeueEnumerator;
    procedure TestElementsToArray;
  end;

  TestIntegerStringPriorityQueue = class(TTestCase)
  strict private
    FPriorityQueue: PriorityQueue<integer, string>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestGetCount;
    procedure TestEnqueue;
    procedure TestDequeue;
    procedure TestDequeueStable;
    procedure TestClear;
    procedure TestContains;
    procedure TestRemove;
    procedure TestEnumerator;
    procedure TestDequeueEnumerator;
  end;

implementation

procedure TestIntegerPriorityQueue.SetUp;
begin
  inherited;

  FPriorityQueue := PriorityQueue<integer>.Create();
end;

procedure TestIntegerPriorityQueue.TearDown;
begin
  FPriorityQueue := nil;

  inherited;
end;

procedure TestIntegerPriorityQueue.TestElementsToArray;
var
  I: NativeInt;
  ReturnValue: TArray<integer>;
  Element: integer;
  SeenElements: TArray<boolean>;
begin
  SetLength(SeenElements, 100);
  for I := 99 downto 0 do
  begin
    FPriorityQueue.Enqueue(I);
    SeenElements[I] := True;
  end;

  ReturnValue := FPriorityQueue.Elements.ToArray();

  CheckEquals(100, Length(ReturnValue), 'TestElementsToArray 1');

  for Element in ReturnValue do
  begin
    CheckTrue(SeenElements[Element], 'TestElementsToArray 2');
    SeenElements[Element] := False;
  end;

  for I := 0 to 99 do
  begin
    CheckFalse(SeenElements[I], 'TestElementsToArray 3');
  end;
end;

procedure TestIntegerPriorityQueue.TestEnqueue;
var
  Element: integer;
begin
  Element := 42;
  FPriorityQueue.Enqueue(Element);

  CheckEquals(Element, FPriorityQueue.First, 'TestEnqueue 1');
  CheckEquals(1, FPriorityQueue.Count, 'TestEnqueue 2');
end;

procedure TestIntegerPriorityQueue.TestEnumerator;
var
  I: NativeInt;
  Element: integer;
  SeenElements: TArray<boolean>;
begin
  SetLength(SeenElements, 100);
  for I := 99 downto 0 do
  begin
    FPriorityQueue.Enqueue(I);
    SeenElements[I] := True;
  end;

  for Element in FPriorityQueue do
  begin
    CheckTrue(SeenElements[Element], 'TestEnumerator 1');
    SeenElements[Element] := False;
  end;

  for I := 0 to 99 do
  begin
    CheckFalse(SeenElements[I], 'TestEnumerator 2');
  end;
end;

procedure TestIntegerPriorityQueue.TestGetCount;
var
  I: NativeInt;
  Count: NativeInt;
begin
  for I := 99 downto 0 do
  begin
    Count := FPriorityQueue.Count;
    CheckEquals(99 - I, Count, 'TestGetCount 1');

    FPriorityQueue.Enqueue(I);

    Count := FPriorityQueue.Count;
    CheckEquals(100 - I, Count, 'TestGetCount 2');
  end;

  for I := 0 to 99 do
  begin
    Count := FPriorityQueue.Count;
    CheckEquals(100 - I, Count, 'TestGetCount 3');

    FPriorityQueue.Dequeue();

    Count := FPriorityQueue.Count;
    CheckEquals(99 - I, Count, 'TestGetCount 4');
  end;
end;

procedure TestIntegerPriorityQueue.TestDequeue;
var
  I: NativeInt;
  ReturnValue: integer;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I);

  for I := 0 to 99 do
  begin
    ReturnValue := FPriorityQueue.Dequeue();
    CheckEquals(I, ReturnValue, 'TestDequeue 1');
  end;
end;

procedure TestIntegerPriorityQueue.TestDequeueEnumerator;
var
  I: NativeInt;
  Element: integer;
  Count: NativeInt;
  SeenElements: TArray<boolean>;
begin
  SetLength(SeenElements, 100);
  for I := 99 downto 0 do
  begin
    FPriorityQueue.Enqueue(I);
    SeenElements[I] := True;
  end;

  for Element in FPriorityQueue.DequedElements() do
  begin
    CheckTrue(SeenElements[Element], 'TestDequeueEnumerator 1');
    SeenElements[Element] := False;
  end;

  Count := FPriorityQueue.Count;
  CheckEquals(0, Count, 'TestDequeueEnumerator 2');

  for I := 0 to 99 do
  begin
    CheckFalse(SeenElements[I], 'TestDequeueEnumerator 3');
  end;
end;

procedure TestIntegerPriorityQueue.TestClear;
var
  I: NativeInt;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I);

  FPriorityQueue.Clear;

  CheckEquals(0, FPriorityQueue.Count, 'TestClear 1');

  StartExpectingException(EArgumentOutOfRangeException);

  FPriorityQueue.First;

  StopExpectingException('TestClear 2');
end;

procedure TestIntegerPriorityQueue.TestContains;
var
  I: NativeInt;
  ReturnValue: Boolean;
  Element: integer;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I);

  Element := 42;
  ReturnValue := FPriorityQueue.Contains(Element);
  CheckTrue(ReturnValue, 'TestContains 1');

  Element := 123;
  ReturnValue := FPriorityQueue.Contains(Element);
  CheckFalse(ReturnValue, 'TestContains 2');
end;

procedure TestIntegerPriorityQueue.TestRemove;
var
  I: NativeInt;
  Element: integer;
  ReturnValue: Boolean;
  Count: NativeInt;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I);

  Element := 42;
  FPriorityQueue.Remove(Element);

  ReturnValue := FPriorityQueue.Contains(Element);
  CheckFalse(ReturnValue, 'TestRemove 1');

  Count := FPriorityQueue.Count;
  CheckEquals(99, Count, 'TestRemove 2');

  Element := 123;
  FPriorityQueue.Remove(Element);

  Count := FPriorityQueue.Count;
  CheckEquals(99, Count, 'TestRemove 3');
end;

{ TestIntegerStringPriorityQueue }

procedure TestIntegerStringPriorityQueue.SetUp;
begin
  inherited;

  FPriorityQueue := PriorityQueue<integer, string>.Create();
end;

procedure TestIntegerStringPriorityQueue.TearDown;
begin
  FPriorityQueue := nil;

  inherited;
end;

procedure TestIntegerStringPriorityQueue.TestClear;
var
  I: NativeInt;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I, I.ToString());

  FPriorityQueue.Clear;

  CheckEquals(0, FPriorityQueue.Count, 'TestClear 1');

  StartExpectingException(EArgumentOutOfRangeException);

  FPriorityQueue.First;

  StopExpectingException('TestClear 2');
end;

procedure TestIntegerStringPriorityQueue.TestContains;
var
  I: NativeInt;
  ReturnValue: Boolean;
  Element: string;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I, I.ToString());

  Element := 42.ToString();
  ReturnValue := FPriorityQueue.Contains(Element);
  CheckTrue(ReturnValue, 'TestContains 1');

  Element := 123.ToString();
  ReturnValue := FPriorityQueue.Contains(Element);
  CheckFalse(ReturnValue, 'TestContains 2');
end;

procedure TestIntegerStringPriorityQueue.TestDequeue;
var
  I: NativeInt;
  ReturnValue: string;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I, I.ToString());

  for I := 0 to 99 do
  begin
    ReturnValue := FPriorityQueue.Dequeue();
    CheckEquals(I.ToString(), ReturnValue, 'TestDequeue 1');
  end;
end;

procedure TestIntegerStringPriorityQueue.TestDequeueEnumerator;
var
  I: NativeInt;
  Element: string;
  Count: NativeInt;
  SeenElements: TArray<boolean>;
begin
  SetLength(SeenElements, 100);
  for I := 99 downto 0 do
  begin
    FPriorityQueue.Enqueue(I, I.ToString());
    SeenElements[I] := True;
  end;

  for Element in FPriorityQueue.DequedElements() do
  begin
    CheckTrue(SeenElements[Element.ToInteger()], 'TestDequeueEnumerator 1');
    SeenElements[Element.ToInteger()] := False;
  end;

  Count := FPriorityQueue.Count;
  CheckEquals(0, Count, 'TestDequeueEnumerator 2');

  for I := 0 to 99 do
  begin
    CheckFalse(SeenElements[I], 'TestDequeueEnumerator 3');
  end;
end;

procedure TestIntegerStringPriorityQueue.TestDequeueStable;
var
  I, J: NativeInt;
  ReturnValue: string;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I div 10, I.ToString());

  for I := 0 to 9 do
  begin
    for J := 9 downto 0 do
    begin
      ReturnValue := FPriorityQueue.Dequeue();
      CheckEquals((I * 10 + J).ToString(), ReturnValue, 'TestDequeueStable 1');
    end;
  end;
end;

procedure TestIntegerStringPriorityQueue.TestEnqueue;
var
  Priority: integer;
  Element: string;
begin
  Priority := 42;
  Element := Priority.ToString();
  FPriorityQueue.Enqueue(Priority, Element);

  CheckEquals(Element, FPriorityQueue.First, 'TestEnqueue 1');
  CheckEquals(1, FPriorityQueue.Count, 'TestEnqueue 2');
end;

procedure TestIntegerStringPriorityQueue.TestEnumerator;
var
  I: NativeInt;
  Element: string;
  SeenElements: TArray<boolean>;
begin
  SetLength(SeenElements, 100);
  for I := 99 downto 0 do
  begin
    FPriorityQueue.Enqueue(I, I.ToString());
    SeenElements[I] := True;
  end;

  for Element in FPriorityQueue do
  begin
    CheckTrue(SeenElements[Element.ToInteger()], 'TestEnumerator 1');
    SeenElements[Element.ToInteger()] := False;
  end;

  for I := 0 to 99 do
  begin
    CheckFalse(SeenElements[I], 'TestEnumerator 2');
  end;
end;

procedure TestIntegerStringPriorityQueue.TestGetCount;
var
  I: NativeInt;
  Count: NativeInt;
begin
  for I := 99 downto 0 do
  begin
    Count := FPriorityQueue.Count;
    CheckEquals(99 - I, Count, 'TestGetCount 1');

    FPriorityQueue.Enqueue(I, I.ToString());

    Count := FPriorityQueue.Count;
    CheckEquals(100 - I, Count, 'TestGetCount 2');
  end;

  for I := 0 to 99 do
  begin
    Count := FPriorityQueue.Count;
    CheckEquals(100 - I, Count, 'TestGetCount 3');

    FPriorityQueue.Dequeue();

    Count := FPriorityQueue.Count;
    CheckEquals(99 - I, Count, 'TestGetCount 4');
  end;
end;

procedure TestIntegerStringPriorityQueue.TestRemove;
var
  I: NativeInt;
  Element: string;
  ReturnValue: Boolean;
  Count: NativeInt;
begin
  for I := 99 downto 0 do
    FPriorityQueue.Enqueue(I, I.ToString());

  Element := 42.ToString();
  FPriorityQueue.Remove(Element);

  ReturnValue := FPriorityQueue.Contains(Element);
  CheckFalse(ReturnValue, 'TestRemove 1');

  Count := FPriorityQueue.Count;
  CheckEquals(99, Count, 'TestRemove 2');

  Element := 123.ToString();
  FPriorityQueue.Remove(Element);

  Count := FPriorityQueue.Count;
  CheckEquals(99, Count, 'TestRemove 3');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestIntegerPriorityQueue.Suite);
  RegisterTest(TestIntegerStringPriorityQueue.Suite);
end.

